{"version":3,"file":"testlib.js","sourceRoot":"","sources":["../../src/test/testlib.ts"],"names":[],"mappings":";AAAA;;;;GAIG;;;;;;;;;;;;AAEH,6BAIa;AACb,iCAAiC;AACjC,mCAA4B;AAG5B,0EAA0E;AAC1E,uEAAuE;AACvE,MAAM,kBAAkB,GAAG,IAAA,gBAAM,EAAC,EAAE,CAAC,CAAC;AAEtC,SAAS,IAAI,CAAqB,IAAO;IACvC,IAAI,GAAG,GAAG,KAAK,CAAC;IAChB,IAAI,GAAG,GAAQ,SAAS,CAAC;IACzB,OAAQ,UAAU,GAAG,IAAW;QAC9B,IAAI,GAAG;YAAE,OAAO,GAAG,CAAC;QACpB,GAAG,GAAG,IAAI,CAAC;QACX,GAAG,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,CAAC;QACpB,OAAO,GAAG,CAAC;IACb,CAAc,CAAC;AACjB,CAAC;AAEY,QAAA,IAAI,GAAG,mBAAmB,CAAC;IACtC,mBAAmB,EAAE,EAAE;IACvB,YAAY,EAAE,KAAK;IACnB,qBAAqB,EAAE,KAAK;IAC5B,SAAS,EAAE,KAAK;IAChB,WAAW,EAAE,SAAS;CACvB,CAAC,CAAC;AAEc,gBARJ,YAAI,CAQK;AACtB,sBAAsB;AACT,QAAA,OAAO,GAAG,YAAI,CAAC,OAAO,CAAC;AA0DpC,SAAS,mBAAmB,CAAU,IAMrC;;IACC,MAAM,EAAE,WAAW,EAAE,SAAS,GAAG,KAAK,EAAE,GAAG,IAAI,CAAC;IAChD,MAAM,mBAAmB,GAAG,CAAC,GAAG,CAAC,MAAA,IAAI,CAAC,mBAAmB,mCAAI,EAAE,CAAC,CAAC,CAAC;IAClE,IAAI,EAAE,YAAY,EAAE,qBAAqB,EAAE,GAAG,IAAI,CAAC;IACnD,IAAI,YAAY,GAAG,KAAK,CAAC;IACzB,IAAI,mBAAmB,GAAG,KAAK,CAAC;IAChC,SAAS,YAAY,CAAC,KAAyB;QAC7C,MAAM,CAAC,KAAK,CAAC,CAAC;QACd,qDAAqD;QACrD,IAAI,WAAW,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;YACxC,OAAO,GAAG,WAAW,GAAG,SAAS,GAAG,KAAK,EAAE,CAAC;SAC7C;QACD,IAAI,WAAW,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,EAAE;YACxC,OAAO,KAAK,CAAC;SACd;IACH,CAAC;IACD,SAAS,SAAS,CAAC,IAAW;QAC5B,MAAM,KAAK,GACT,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,CAAE,IAAI,CAAC,KAAK,EAAa,CAAC,CAAC,CAAC,SAAS,CAAC;QACrE,MAAM,MAAM,GACV,OAAO,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU;YAC3B,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,EAAc,CAAC;YAC5B,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;gBACxB,CAAC,CAAE,IAAI,CAAC,KAAK,EAAiB;gBAC9B,CAAC,CAAC,EAAE,CAAC;QACT,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC;IACjC,CAAC;IACD,SAAS,8BAA8B;QACrC,mBAAmB,GAAG,IAAI,CAAC;IAC7B,CAAC;IACD,SAAS,8BAA8B;QACrC,IAAI,mBAAmB,EAAE;YACvB,MAAM,IAAI,KAAK,CACb,6DAA6D,CAC9D,CAAC;SACH;QACD,YAAY,GAAG,IAAI,CAAC;IACtB,CAAC;IACD;;OAEG;IACH,SAAS,WAAW,CAClB,KAAyB,EACzB,MAAkB,EAClB,kBAA4B,EAC5B,IAAW;QAEX,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE;YACzC,OAAO,UAAgB,CAA4B,EAAE,GAAG,IAAW;;oBACjE,OAAO,kBAAkB,CAAC,GAAS,EAAE;wBACnC,IAAI,CAAC,GAAG,CAAC,CAAC;wBACV,KAAK,MAAM,IAAI,IAAI,mBAAmB,EAAE;4BACtC,MAAM,IAAI,CAAC,CAAC,CAAC,CAAC;4BACd,CAAC,EAAE,CAAC;yBACL;wBACD,OAAO,KAAK,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,CAAC;oBAC3B,CAAC,CAAA,CAAC,CAAC;gBACL,CAAC;aAAA,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,MAAM,aAAa,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;QAC1C,kBAAkB,CAAC,aAAa,EAAE,aAAa,EAAE,GAAG,IAAI,CAAC,CAAC;IAC5D,CAAC;IACD,SAAS,IAAI,CAAC,GAAG,SAAgB;QAC/B,8BAA8B,EAAE,CAAC;QACjC,gCAAgC;QAChC,iJAAiJ;QACjJ,0BAA0B;QAC1B,6FAA6F;QAC7F,mKAAmK;QACnK,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;QACrD,OAAO,WAAW,CAChB,KAAK,EACL,MAAM,EACN,qBAAqB,CAAC,CAAC,CAAC,aAAO,CAAC,MAAM,CAAC,CAAC,CAAC,aAAO,EAChD,IAAI,CACL,CAAC;IACJ,CAAC;IACD,IAAI,CAAC,MAAM,GAAG,UAAU,GAAG,SAAgB;QACzC,8BAA8B,EAAE,CAAC;QACjC,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,GAAG,SAAS,CAAC,SAAS,CAAC,CAAC;QACrD,OAAO,WAAW,CAAC,KAAK,EAAE,MAAM,EAAE,aAAO,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC,CAAC;IACF,IAAI,CAAC,UAAU,GAAG,UAChB,EAAsD;QAEtD,8BAA8B,EAAE,CAAC;QACjC,mBAAmB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC/B,CAAC,CAAC;IACF,IAAI,CAAC,OAAO,GAAG,UACb,EAAqD;QAErD,8BAA8B,EAAE,CAAC;QACjC,mBAAmB,CAAC,IAAI,CAAC,CAAO,CAA4B,EAAE,EAAE;YAC9D,MAAM,kBAAkB,GAAG,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;YACvC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC;QAC/C,CAAC,CAAA,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC,CAAC;IACF,IAAI,CAAC,SAAS,GAAG,UACf,EAAsD;QAEtD,8BAA8B,EAAE,CAAC;QACjC,YAAY,GAAG,IAAI,CAAC;QACpB,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;IACrC,CAAC,CAAC;IACF,IAAI,CAAC,KAAK,GAAG,UACX,EAOqD;QAErD,SAAS,KAAK,CAAC,aAAwC,EAAE,GAAG,IAAU;YACpE,MAAM,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YACxB,MAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;YACxD,OAAO,aAAa,CAAC,aAAa,CAAC,CAAC;QACtC,CAAC;QACD,KAAK,CAAC,KAAK,GAAG,UAAU,UAA8B,EAAE,GAAG,IAAU;YACnE,MAAM,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;YACxB,OAAO,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC;QAC9D,CAAC,CAAC;QACF,OAAO,KAAK,CAAC;IACf,CAAC,CAAC;IACF,IAAI,CAAC,KAAK,GAAG,UACX,KAAa,EACb,EAA0C;QAE1C,MAAM,MAAM,GAAG,mBAAmB,CAAU;YAC1C,YAAY;YACZ,qBAAqB;YACrB,SAAS;YACT,WAAW,EAAE,YAAY,CAAC,KAAK,CAAC;YAChC,mBAAmB;SACpB,CAAC,CAAC;QACH,EAAE,CAAC,MAAM,CAAC,CAAC;IACb,CAAC,CAAC;IACF,IAAI,CAAC,WAAW,GAAG;QACjB,qBAAqB,GAAG,IAAI,CAAC;IAC/B,CAAC,CAAC;IACF,OAAO,IAAW,CAAC;AACrB,CAAC","sourcesContent":["/*\n * Extensions to ava, for declaring and running test cases and suites\n * Utilities specific to testing ts-node, for example handling streams and exec-ing processes,\n * should go in a separate module.\n */\n\nimport avaTest, {\n  ExecutionContext,\n  Implementation,\n  OneOrMoreMacros,\n} from 'ava';\nimport * as assert from 'assert';\nimport throat from 'throat';\nexport { ExecutionContext };\n\n// NOTE: this limits concurrency within a single process, but AVA launches\n// each .spec file in its own process, so actual concurrency is higher.\nconst concurrencyLimiter = throat(16);\n\nfunction once<T extends Function>(func: T): T {\n  let run = false;\n  let ret: any = undefined;\n  return (function (...args: any[]) {\n    if (run) return ret;\n    run = true;\n    ret = func(...args);\n    return ret;\n  } as any) as T;\n}\n\nexport const test = createTestInterface({\n  beforeEachFunctions: [],\n  mustDoSerial: false,\n  automaticallyDoSerial: false,\n  separator: ' > ',\n  titlePrefix: undefined,\n});\n// In case someone wants to `const test = _test.context()`\nexport { test as _test };\n// Or import `context`\nexport const context = test.context;\n\nexport interface TestInterface<\n  Context\n> /*extends Omit<AvaTestInterface<Context>, 'before' | 'beforeEach' | 'after' | 'afterEach' | 'failing' | 'serial'>*/ {\n  //#region copy-pasted from ava's .d.ts\n  /** Declare a concurrent test. */\n  (title: string, implementation: Implementation<Context>): void;\n  /** Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro. */\n  <T extends any[]>(\n    title: string,\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n  /** Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title. */\n  <T extends any[]>(macros: OneOrMoreMacros<T, Context>, ...rest: T): void;\n  //#endregion\n\n  serial(title: string, implementation: Implementation<Context>): void;\n  /** Declare a concurrent test that uses one or more macros. Additional arguments are passed to the macro. */\n  serial<T extends any[]>(\n    title: string,\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n  /** Declare a concurrent test that uses one or more macros. The macro is responsible for generating a unique test title. */\n  serial<T extends any[]>(\n    macros: OneOrMoreMacros<T, Context>,\n    ...rest: T\n  ): void;\n\n  macro<Args extends any[]>(\n    cb: (\n      ...args: Args\n    ) =>\n      | [\n          (title: string | undefined) => string | undefined,\n          (t: ExecutionContext<Context>) => Promise<void>\n        ]\n      | ((t: ExecutionContext<Context>) => Promise<void>)\n  ): (\n    test: ExecutionContext<Context>,\n    ...args: Args\n  ) => Promise<void> & {\n    title(givenTitle: string | undefined, ...args: Args): string;\n  };\n\n  beforeAll(cb: (t: ExecutionContext<Context>) => Promise<void>): void;\n  beforeEach(cb: (t: ExecutionContext<Context>) => Promise<void>): void;\n  context<T extends object | void>(\n    cb: (t: ExecutionContext<Context>) => Promise<T>\n  ): TestInterface<Context & T>;\n  suite(title: string, cb: (test: TestInterface<Context>) => void): void;\n\n  runSerially(): void;\n\n  // TODO add teardownEach\n}\nfunction createTestInterface<Context>(opts: {\n  titlePrefix: string | undefined;\n  separator: string | undefined;\n  mustDoSerial: boolean;\n  automaticallyDoSerial: boolean;\n  beforeEachFunctions: Function[];\n}): TestInterface<Context> {\n  const { titlePrefix, separator = ' > ' } = opts;\n  const beforeEachFunctions = [...(opts.beforeEachFunctions ?? [])];\n  let { mustDoSerial, automaticallyDoSerial } = opts;\n  let hookDeclared = false;\n  let suiteOrTestDeclared = false;\n  function computeTitle(title: string | undefined) {\n    assert(title);\n    // return `${ titlePrefix }${ separator }${ title }`;\n    if (titlePrefix != null && title != null) {\n      return `${titlePrefix}${separator}${title}`;\n    }\n    if (titlePrefix == null && title != null) {\n      return title;\n    }\n  }\n  function parseArgs(args: any[]) {\n    const title =\n      typeof args[0] === 'string' ? (args.shift() as string) : undefined;\n    const macros =\n      typeof args[0] === 'function'\n        ? [args.shift() as Function]\n        : Array.isArray(args[0])\n        ? (args.shift() as Function[])\n        : [];\n    return { title, macros, args };\n  }\n  function assertOrderingForDeclaringTest() {\n    suiteOrTestDeclared = true;\n  }\n  function assertOrderingForDeclaringHook() {\n    if (suiteOrTestDeclared) {\n      throw new Error(\n        'Hooks must be declared before declaring sub-suites or tests'\n      );\n    }\n    hookDeclared = true;\n  }\n  /**\n   * @param avaDeclareFunction either test or test.serial\n   */\n  function declareTest(\n    title: string | undefined,\n    macros: Function[],\n    avaDeclareFunction: Function,\n    args: any[]\n  ) {\n    const wrappedMacros = macros.map((macro) => {\n      return async function (t: ExecutionContext<Context>, ...args: any[]) {\n        return concurrencyLimiter(async () => {\n          let i = 0;\n          for (const func of beforeEachFunctions) {\n            await func(t);\n            i++;\n          }\n          return macro(t, ...args);\n        });\n      };\n    });\n    const computedTitle = computeTitle(title);\n    avaDeclareFunction(computedTitle, wrappedMacros, ...args);\n  }\n  function test(...inputArgs: any[]) {\n    assertOrderingForDeclaringTest();\n    // TODO is this safe to disable?\n    // X parallel tests will each invoke the beforeAll hook, but once()ification means each invocation will return the same promise, and tests cannot\n    // start till it finishes.\n    // HOWEVER if it returns a single shared state, can tests concurrently use this shared state?\n    // if(!automaticallyDoSerial && mustDoSerial) throw new Error('Cannot declare non-serial tests because you have declared a beforeAll() hook for this test suite.');\n    const { args, macros, title } = parseArgs(inputArgs);\n    return declareTest(\n      title,\n      macros,\n      automaticallyDoSerial ? avaTest.serial : avaTest,\n      args\n    );\n  }\n  test.serial = function (...inputArgs: any[]) {\n    assertOrderingForDeclaringTest();\n    const { args, macros, title } = parseArgs(inputArgs);\n    return declareTest(title, macros, avaTest.serial, args);\n  };\n  test.beforeEach = function (\n    cb: (test: ExecutionContext<Context>) => Promise<void>\n  ) {\n    assertOrderingForDeclaringHook();\n    beforeEachFunctions.push(cb);\n  };\n  test.context = function (\n    cb: (test: ExecutionContext<Context>) => Promise<any>\n  ) {\n    assertOrderingForDeclaringHook();\n    beforeEachFunctions.push(async (t: ExecutionContext<Context>) => {\n      const addedContextFields = await cb(t);\n      Object.assign(t.context, addedContextFields);\n    });\n    return test;\n  };\n  test.beforeAll = function (\n    cb: (test: ExecutionContext<Context>) => Promise<void>\n  ) {\n    assertOrderingForDeclaringHook();\n    mustDoSerial = true;\n    beforeEachFunctions.push(once(cb));\n  };\n  test.macro = function <Args extends any[]>(\n    cb: (\n      ...args: Args\n    ) =>\n      | [\n          (title: string | undefined) => string,\n          (t: ExecutionContext<Context>) => Promise<void>\n        ]\n      | ((t: ExecutionContext<Context>) => Promise<void>)\n  ) {\n    function macro(testInterface: ExecutionContext<Context>, ...args: Args) {\n      const ret = cb(...args);\n      const macroFunction = Array.isArray(ret) ? ret[1] : ret;\n      return macroFunction(testInterface);\n    }\n    macro.title = function (givenTitle: string | undefined, ...args: Args) {\n      const ret = cb(...args);\n      return Array.isArray(ret) ? ret[0](givenTitle) : givenTitle;\n    };\n    return macro;\n  };\n  test.suite = function (\n    title: string,\n    cb: (test: TestInterface<Context>) => void\n  ) {\n    const newApi = createTestInterface<Context>({\n      mustDoSerial,\n      automaticallyDoSerial,\n      separator,\n      titlePrefix: computeTitle(title),\n      beforeEachFunctions,\n    });\n    cb(newApi);\n  };\n  test.runSerially = function () {\n    automaticallyDoSerial = true;\n  };\n  return test as any;\n}\n"]}