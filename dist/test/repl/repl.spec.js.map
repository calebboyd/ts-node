{"version":3,"file":"repl.spec.js","sourceRoot":"","sources":["../../../src/test/repl/repl.spec.ts"],"names":[],"mappings":"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","sourcesContent":["import { ts } from '../helpers';\nimport semver = require('semver');\nimport * as expect from 'expect';\nimport {\n  CMD_TS_NODE_WITH_PROJECT_FLAG,\n  contextTsNodeUnderTest,\n  getStream,\n  TEST_DIR,\n} from '../helpers';\nimport { createExec, createExecTester } from '../exec-helpers';\nimport { upstreamTopLevelAwaitTests } from './node-repl-tla';\nimport { _test } from '../testlib';\nimport { contextReplHelpers } from './helpers';\nimport { promisify } from 'util';\n\nconst test = _test.context(contextTsNodeUnderTest).context(contextReplHelpers);\n\nconst exec = createExec({\n  cwd: TEST_DIR,\n});\n\nconst execTester = createExecTester({\n  cmd: CMD_TS_NODE_WITH_PROJECT_FLAG,\n  exec,\n});\n\ntest('should run REPL when --interactive passed and stdin is not a TTY', async () => {\n  const execPromise = exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive`);\n  execPromise.child.stdin!.end('console.log(\"123\")\\n');\n  const { err, stdout } = await execPromise;\n  expect(err).toBe(null);\n  expect(stdout).toBe('> 123\\n' + 'undefined\\n' + '> ');\n});\n\ntest('REPL has command to get type information', async () => {\n  const execPromise = exec(`${CMD_TS_NODE_WITH_PROJECT_FLAG} --interactive`);\n  execPromise.child.stdin!.end('\\nconst a = 123\\n.type a');\n  const { err, stdout } = await execPromise;\n  expect(err).toBe(null);\n  expect(stdout).toBe(\n    '> undefined\\n' + '> undefined\\n' + '> const a: 123\\n' + '> '\n  );\n});\n\n// Serial because it's timing-sensitive\ntest.serial('REPL can be configured on `start`', async (t) => {\n  const prompt = '#> ';\n\n  const { stdout, stderr } = await t.context.executeInRepl('const x = 3', {\n    registerHooks: true,\n    startInternalOptions: {\n      prompt,\n      ignoreUndefined: true,\n    },\n  });\n\n  expect(stderr).toBe('');\n  expect(stdout).toBe(`${prompt}${prompt}`);\n});\n\n// Serial because it's timing-sensitive\ntest.serial(\n  'REPL uses a different context when `useGlobal` is false',\n  async (t) => {\n    const { stdout, stderr } = await t.context.executeInRepl(\n      // No error when re-declaring x\n      'const x = 3\\n' +\n        // console.log ouput will end up in the stream and not in test output\n        'console.log(1)\\n',\n      {\n        registerHooks: true,\n        waitPattern: `> undefined\\n> 1\\nundefined\\n> `,\n        startInternalOptions: {\n          useGlobal: false,\n        },\n      }\n    );\n\n    expect(stderr).toBe('');\n    expect(stdout).toBe(`> undefined\\n> 1\\nundefined\\n> `);\n  }\n);\n\n// Serial because it's timing-sensitive\ntest.serial('REPL can be created via API', async (t) => {\n  const { stdout, stderr } = await t.context.executeInRepl(\n    `\\nconst a = 123\\n.type a\\n`,\n    {\n      registerHooks: true,\n      waitPattern: '123\\n> ',\n    }\n  );\n  expect(stderr).toBe('');\n  expect(stdout).toBe(\n    '> undefined\\n' + '> undefined\\n' + '> const a: 123\\n' + '> '\n  );\n});\n\ntest.suite('top level await', (_test) => {\n  const compilerOptions = {\n    target: 'es2018',\n  };\n  const test = _test.context(async (t) => {\n    return { executeInTlaRepl };\n\n    function executeInTlaRepl(input: string, waitPattern?: string | RegExp) {\n      return t.context.executeInRepl(\n        input\n          .split('\\n')\n          .map((line) => line.trim())\n          // Restore newline once https://github.com/nodejs/node/pull/39392 is merged\n          .join(''),\n        {\n          registerHooks: true,\n          waitPattern,\n          createServiceOpts: {\n            experimentalReplAwait: true,\n            compilerOptions,\n          },\n          startInternalOptions: { useGlobal: false },\n        }\n      );\n    }\n  });\n\n  if (semver.gte(ts.version, '3.8.0')) {\n    // Serial because it's timing-sensitive\n    test.serial('should allow evaluating top level await', async (t) => {\n      const script = `\n        const x: number = await new Promise((r) => r(1));\n        for await (const x of [1,2,3]) { console.log(x) };\n        for (const x of ['a', 'b']) { await x; console.log(x) };\n        class Foo {}; await 1;\n        function Bar() {}; await 2;\n        const {y} = await ({y: 2});\n        const [z] = await [3];\n        x + y + z;\n      `;\n\n      const { stdout, stderr } = await t.context.executeInTlaRepl(\n        script,\n        '6\\n> '\n      );\n      expect(stderr).toBe('');\n      expect(stdout).toBe('> 1\\n2\\n3\\na\\nb\\n6\\n> ');\n    });\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'should wait until promise is settled when awaiting at top level',\n      async (t) => {\n        const awaitMs = 500;\n        const script = `\n          const startTime = new Date().getTime();\n          await new Promise((r) => setTimeout(() => r(1), ${awaitMs}));\n          const endTime = new Date().getTime();\n          endTime - startTime;\n        `;\n        const { stdout, stderr } = await t.context.executeInTlaRepl(\n          script,\n          /\\d+\\n/\n        );\n\n        expect(stderr).toBe('');\n\n        const elapsedTimeString = stdout\n          .split('\\n')[0]\n          .replace('> ', '')\n          .trim();\n        expect(elapsedTimeString).toMatch(/^\\d+$/);\n        const elapsedTime = Number(elapsedTimeString);\n        expect(elapsedTime).toBeGreaterThanOrEqual(awaitMs - 50);\n        // When CI is taxed, the time may be *much* greater than expected.\n        // I can't think of a case where the time being *too high* is a bug\n        // that this test can catch.  So I've made this check very loose.\n        expect(elapsedTime).toBeLessThanOrEqual(awaitMs + 10e3);\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'should not wait until promise is settled when not using await at top level',\n      async (t) => {\n        const script = `\n          const startTime = new Date().getTime();\n          (async () => await new Promise((r) => setTimeout(() => r(1), ${5000})))();\n          const endTime = new Date().getTime();\n          endTime - startTime;\n        `;\n        const { stdout, stderr } = await t.context.executeInTlaRepl(\n          script,\n          /\\d+\\n/\n        );\n\n        expect(stderr).toBe('');\n\n        const ellapsedTime = Number(\n          stdout.split('\\n')[0].replace('> ', '').trim()\n        );\n        expect(ellapsedTime).toBeGreaterThanOrEqual(0);\n        // Should ideally be instantaneous; leave wiggle-room for slow CI\n        expect(ellapsedTime).toBeLessThanOrEqual(100);\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'should error with typing information when awaited result has type mismatch',\n      async (t) => {\n        const { stdout, stderr } = await t.context.executeInTlaRepl(\n          'const x: string = await 1',\n          'error'\n        );\n\n        expect(stdout).toBe('> > ');\n        expect(stderr.replace(/\\r\\n/g, '\\n')).toBe(\n          '<repl>.ts(4,7): error TS2322: ' +\n            (semver.gte(ts.version, '4.0.0')\n              ? `Type 'number' is not assignable to type 'string'.\\n`\n              : `Type '1' is not assignable to type 'string'.\\n`) +\n            '\\n'\n        );\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'should error with typing information when importing a file with type errors',\n      async (t) => {\n        const { stdout, stderr } = await t.context.executeInTlaRepl(\n          `const {foo} = await import('./tests/repl/tla-import');`,\n          'error'\n        );\n\n        expect(stdout).toBe('> > ');\n        expect(stderr.replace(/\\r\\n/g, '\\n')).toBe(\n          'tests/repl/tla-import.ts(1,14): error TS2322: ' +\n            (semver.gte(ts.version, '4.0.0')\n              ? `Type 'number' is not assignable to type 'string'.\\n`\n              : `Type '1' is not assignable to type 'string'.\\n`) +\n            '\\n'\n        );\n      }\n    );\n\n    test('should pass upstream test cases', async (t) => {\n      const { tsNodeUnderTest } = t.context;\n      upstreamTopLevelAwaitTests({ TEST_DIR, tsNodeUnderTest });\n    });\n  } else {\n    test('should throw error when attempting to use top level await on TS < 3.8', async (t) => {\n      expect(t.context.executeInTlaRepl('')).rejects.toThrow(\n        'Experimental REPL await is not compatible with TypeScript versions older than 3.8'\n      );\n    });\n  }\n});\n\ntest.suite(\n  'REPL ignores diagnostics that are annoying in interactive sessions',\n  (test) => {\n    const code = `function foo() {};\\nfunction foo() {return 123};\\nconsole.log(foo());\\n`;\n    const diagnosticMessage = `Duplicate function implementation`;\n    test('interactive repl should ignore them', async (t) => {\n      const { stdout, stderr } = await execTester({\n        flags: '-i',\n        stdin: code,\n      });\n      expect(stdout).not.toContain(diagnosticMessage);\n    });\n    test('interactive repl should not ignore them if they occur in other files', async (t) => {\n      const { stdout, stderr } = await execTester({\n        flags: '-i',\n        stdin: `import './repl-ignored-diagnostics/index.ts';\\n`,\n      });\n      expect(stderr).toContain(diagnosticMessage);\n    });\n    test('[stdin] should not ignore them', async (t) => {\n      const { stdout, stderr } = await execTester({\n        stdin: code,\n        expectError: true,\n      });\n      expect(stderr).toContain(diagnosticMessage);\n    });\n    test('[eval] should not ignore them', async (t) => {\n      const { stdout, stderr } = await execTester({\n        flags: `-e \"${code.replace(/\\n/g, '')}\"`,\n        expectError: true,\n      });\n      expect(stderr).toContain(diagnosticMessage);\n    });\n  }\n);\n\ntest.suite(\n  'REPL inputs are syntactically independent of each other',\n  (test) => {\n    // Serial because it's timing-sensitive\n    test.serial(\n      'arithmetic operators are independent of previous values',\n      async (t) => {\n        const { stdout, stderr } = await t.context.executeInRepl(\n          `9\n          + 3\n          7\n          - 3\n          3\n          * 7\\n.break\n          100\n          / 2\\n.break\n          5\n          ** 2\\n.break\n          console.log('done!')\n          `,\n          {\n            registerHooks: true,\n            startInternalOptions: { useGlobal: false },\n            waitPattern: 'done!\\nundefined\\n>',\n          }\n        );\n        expect(stdout).not.toContain('12');\n        expect(stdout).not.toContain('4');\n        expect(stdout).not.toContain('21');\n        expect(stdout).not.toContain('50');\n        expect(stdout).not.toContain('25');\n        expect(stdout).toContain('3');\n        expect(stdout).toContain('-3');\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'automatically inserted semicolons do not appear in error messages at the end',\n      async (t) => {\n        const { stdout, stderr } = await t.context.executeInRepl(\n          `(\n          a\n          console.log('done!')`,\n          {\n            registerHooks: true,\n            startInternalOptions: { useGlobal: false },\n            waitPattern: 'done!\\nundefined\\n>',\n          }\n        );\n        expect(stderr).toContain(\"error TS1005: ')' expected.\");\n        expect(stderr).not.toContain(';');\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'automatically inserted semicolons do not appear in error messages at the start',\n      async (t) => {\n        const { stdout, stderr } = await t.context.executeInRepl(\n          `)\n          console.log('done!')`,\n          {\n            registerHooks: true,\n            startInternalOptions: { useGlobal: false },\n            waitPattern: 'done!\\nundefined\\n>',\n          }\n        );\n        expect(stderr).toContain(\n          'error TS1128: Declaration or statement expected.'\n        );\n        expect(stderr).toContain(')');\n        expect(stderr).not.toContain(';');\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'automatically inserted semicolons do not break function calls',\n      async (t) => {\n        const { stdout, stderr } = await t.context.executeInRepl(\n          `function foo(a: number) {\n              return a + 1;\n          }\n          foo(\n            1\n          )`,\n          {\n            registerHooks: true,\n            startInternalOptions: { useGlobal: false },\n            waitPattern: '2\\n>',\n          }\n        );\n        expect(stderr).toBe('');\n        expect(stdout).toContain('2');\n      }\n    );\n\n    // Serial because it's timing-sensitive\n    test.serial(\n      'automatically inserted semicolons do not affect subsequent line numbers',\n      async (t) => {\n        // If first line of input ends in a semicolon, should not add a second semicolon.\n        // That will cause an extra blank line in the compiled output which will\n        // offset the stack line number.\n        const { stdout, stderr } = await t.context.executeInRepl(\n          `1;\n          new Error().stack!.split('\\\\n')[1]\n          console.log('done!')`,\n          {\n            registerHooks: true,\n            startInternalOptions: { useGlobal: false },\n            waitPattern: 'done!',\n          }\n        );\n        expect(stderr).toBe('');\n        expect(stdout).toContain(\":1:1'\\n\");\n      }\n    );\n  }\n);\n\ntest.suite('REPL works with traceResolution', (test) => {\n  test.serial(\n    'startup traces should print before the prompt appears when traceResolution is enabled',\n    async (t) => {\n      const repl = t.context.createReplViaApi({\n        registerHooks: false as true,\n        createServiceOpts: {\n          compilerOptions: {\n            traceResolution: true,\n          },\n        },\n      });\n\n      repl.replService.start();\n\n      repl.stdin.end();\n\n      await promisify(setTimeout)(3e3);\n\n      repl.stdout.end();\n      const stdout = await getStream(repl.stdout);\n\n      expect(stdout).toContain('======== Resolving module');\n      expect(stdout.endsWith('> ')).toBe(true);\n    }\n  );\n\n  test.serial(\n    'traces should NOT appear when traceResolution is not enabled',\n    async (t) => {\n      const { stdout, stderr } = await t.context.executeInRepl('1', {\n        registerHooks: true,\n        startInternalOptions: { useGlobal: false },\n        waitPattern: '1\\n>',\n      });\n      expect(stderr).toBe('');\n      expect(stdout).not.toContain('======== Resolving module');\n    }\n  );\n});\n\ntest.serial('REPL declares types for node built-ins within REPL', async (t) => {\n  const { stdout, stderr } = await t.context.executeInRepl(\n    `util.promisify(setTimeout)(\"should not be a string\" as string)\n    type Duplex = stream.Duplex\n    const s = stream\n    'done'`,\n    {\n      registerHooks: true,\n      waitPattern: `done`,\n      startInternalOptions: {\n        useGlobal: false,\n      },\n    }\n  );\n\n  // Assert that we receive a typechecking error about improperly using\n  // `util.promisify` but *not* an error about the absence of `util`\n  expect(stderr).not.toMatch(\"Cannot find name 'util'\");\n  expect(stderr).toMatch(\n    \"Argument of type 'string' is not assignable to parameter of type 'number'\"\n  );\n  // Assert that both types and values can be used without error\n  expect(stderr).not.toMatch(\"Cannot find namespace 'stream'\");\n  expect(stderr).not.toMatch(\"Cannot find name 'stream'\");\n  expect(stdout).toMatch(`done`);\n});\n"]}